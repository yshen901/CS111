/*
  NAME : YUCI SHEN
  EMAIL: SHEN.YUCI11@GMAIL.COM
  UID  : 604836772
*/

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <termios.h>
#include <getopt.h>
#include <poll.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <string.h>
#include <errno.h>
#include <netdb.h>
#include <netinet/in.h>

#define ETX '\003' // End of text (^C)
#define EOF2 '\004' // End of transmission (^D)
#define LF '\012'  // Line feed
#define CR '\015'  // Carriage return

#define READ 0
#define WRITE 1

char crlf[2] = {CR, LF};
int pid;
int term_to_shell[2];
int shell_to_term[2];

struct termios saved_attributes;

/* ------------------
    HELPER FUNCTIONS 
   ------------------ */
int safe_write(int fd, char * message, int length, char * target) {
  int write_status;
  if ((write_status = write(fd, message, length)) < 0) {
    fprintf(stderr, "ERROR writing to %s%s", target, crlf);
    exit(1);
  }
  return write_status;
}

int safe_read(int fd, char * buffer, int length, char * source) {
  int read_status;
  if ((read_status = read(fd, buffer, length)) < 0) {
    fprintf(stderr, "ERROR reading from %s%s", source, crlf);
    exit(1);
  }
  return read_status;
}

void err_mess(char* message) {
  fprintf(stderr, "%s: %s%s", message, strerror(errno), crlf);
  exit(1);
}


/* --------------------
   INPUT MODE FUNCTIONS
   -------------------- */
void save_input_mode () {
  tcgetattr(STDIN_FILENO, &saved_attributes);
}

void reset_input_mode () {
  tcsetattr(STDIN_FILENO, TCSANOW, &saved_attributes);
}

void set_input_mode () {
  struct termios tattr;

  if (!isatty(STDIN_FILENO)) { // STDIN must be terminal
    fprintf(stderr, "STDIN is not a terminal.\n");
    exit(1);
  }

  save_input_mode();        // save current input settings
  atexit(reset_input_mode); // and restore at exit

  tcgetattr(STDIN_FILENO, &tattr); // get and modify the current input mode
  tattr.c_iflag = ISTRIP;          
  tattr.c_oflag = 0;
  tattr.c_lflag = 0;
  tattr.c_cc[VTIME] = 0;           // disables timed read
  tattr.c_cc[VMIN] = 1;            // enables a counted read that requires at least 1 char
  tcsetattr(STDIN_FILENO, TCSAFLUSH, &tattr); 
}

/* ---------
   MAIN CODE
   --------- */
int main(int argc, char** argv) {
  /* Variables to store infomation */
  char c;
  char buffer[256];

  /* Variables to store reading and polling status*/
  int read_status;
  int poll_status;

  /* Variables to store argument flags and options */
  int port_flag = 0;
  int log_flag = 0;

  /* Variables for socket communication */
  int sock_fd, port_num;
  struct sockaddr_in serv_addr;
  struct hostent *server;
  
  int option_index = 0;
  static struct option long_options[] = {
    {"log", required_argument, 0, 'l'},
    {"port", required_argument, 0, 'p'},
    {0,0,0,0}
  };

  while((c = getopt_long(argc, argv, "", long_options, &option_index)) != -1) {
    switch(c) {
      case 'l':
	log_flag = 1;
	break;
      case 'p':
	port_flag = 1;
	port_num = atoi(optarg);
	break;
      case '?':
      default:
        fprintf(stderr, "%s: Please use --shell or no argument\n", strerror(errno));
        exit(1);
    }
  }

  /* TRIGGER ERROR IF: 1) port option isn't triggered or 2) port number is reserved */
  if (port_flag == 0) {
    fprintf(stderr, "Port option is mandatory, please use --port={port number} to specify the port");
    exit(1);
  }
  else if (port_num < 1024) {
    fprintf(stderr, "Port number is reserved, please use a port number greater than 1024");
    exit(1);
  }
  
  set_input_mode();

  /* SETUP: SOCKET */
  sock_fd = socket(AF_INET, SOCK_STREAM, 0); // Create a socket
  if (sock_fd < 0)
    err_mess("ERROR opening socket");
  
  server = gethostbyname("localhost"); // Get server information (hostent)
  if (server == NULL)
    err_mess("ERROR getting host name");

  bzero((char *) &serv_addr, sizeof(serv_addr)); // Setup servaddr_in using the hostent
  serv_addr.sin_family = AF_INET;
  bcopy((char*)server->h_addr, (char*)&serv_addr.sin_addr.s_addr, server->h_length);
  serv_addr.sin_port = htons(port_num);

  if (connect(sock_fd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) // Establish connection
    err_mess("ERROR connecting to socket");

  /* DEBUG: Testing whether socket connection succeeded */
  safe_write(sock_fd, "Connection Pending", 18, "socket");
  safe_read(sock_fd, buffer, 255, "socket");
  printf("Received: %s%s", buffer, crlf);

  /* POLLING: keyboard and socket */
  struct pollfd fds[] = {
    {STDIN_FILENO, POLLIN|POLLHUP|POLLERR, 0},
    {sock_fd, POLLIN|POLLHUP|POLLERR, 0}
  };
  
  while(1) {
    if ((poll_status = poll(fds, 2, 0)) < 0)
      err_mess("ERROR polling");

    /* Polls from the keyboard */
    if (fds[0].revents & POLLIN) {
      read_status = safe_read(fds[0].fd, buffer, 256, "keyboard");
      safe_write(STDIN_FILENO, "SENT: ", 6, "terminal");
      for (int i = 0; i < read_status; i++) {
	c = buffer[i];
	if (c == CR || c == LF) {
	  c = LF;
	  safe_write(sock_fd, &c, 1, "socket");
	  safe_write(STDOUT_FILENO, crlf, 2, "terminal");
	}
	else {
	  safe_write(sock_fd, &c, 1, "socket"); 
	  safe_write(STDOUT_FILENO, &c, 1, "terminal");
	}
      }
      safe_write(STDIN_FILENO, crlf, 2, "terminal");
    }
    else if (fds[0].revents & POLLHUP || fds[0].revents & POLLERR) {
      fprintf(stderr, "ERROR polling keyboard%s", crlf);
      exit(1);
    }

    /* Polls from the socket */
    if (fds[1].revents & POLLIN) {
      read_status = safe_read(fds[1].fd, buffer, 256, "socket");

      /* Exits if the read is 0, which only happens if the server socket closes */
      if (read_status <= 0) { 
	close(sock_fd);
	safe_write(STDOUT_FILENO, "Server closed", 13, "terminal");
	safe_write(STDOUT_FILENO, crlf, 2, "terminal");
	exit(0);
      }
      
      safe_write(STDIN_FILENO, "RECEIVED: ", 10, "terminal");
      for (int i = 0; i < read_status; i++) {
	c = buffer[i];
	safe_write(STDIN_FILENO, &c, 1, "terminal");
      }
      safe_write(STDIN_FILENO, crlf, 2, "terminal");
    }
    else if (fds[1].revents & POLLERR) {
      fprintf(stderr, "ERROR while polling socket%s", crlf);
      exit(1);
    }
    else if (fds[1].revents & POLLHUP) {
      fprintf(stderr, "ERROR socket connection hung up%s", crlf);
      exit(1);
    }
  }
  
  exit(0);
}
